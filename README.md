# rk3588_learning
## 定位：这是一个“可复盘、可复习、可对外展示”的学习型仓库，完整记录我从零开始在 Rockchip RK3588 开发板上进行 AI 模型部署（YOLO / Pose 等） 的工程化学习过程。

    目标不是堆代码，而是形成一条清晰的成长路径。

# 🚀 RK3588 AI 全栈学习项目

## 🧭 学习路线图

- [x] 第一阶段：地基篇（第 1-3 周）- **当前进度**
- [ ] 第二阶段：模型篇（第 4-6 周）
- [ ] 第三阶段：加速篇（第 7-9 周）
- [ ] 第四阶段：集成篇（第 10-12 周）

---

## 📓 研发日记 (Engineering Journal)

# Week 03: 实时视频流捕获与硬件排障

## 1. 实验目标
- 实现 RK3588/虚拟机 环境下 USB 摄像头的实时读取。
- 使用 OpenCV 进行简单的图像加工（画框、写字）。
- 建立 无显示器（Headless）场景 下的调试方式：SSH + 定时存图。

## 2. 核心逻辑（视觉四步）
1. **初始化**：使用`cv::VideoCapture` 打开摄像头设备，底层通过 V4L2 协议与内核驱动交互。
2. **配置**：强制设置 `MJPG` 格式与 `320x240` 分辨率以优化带宽。
3. **循环**：`while(true)` 持续读取 `frame` 矩阵。
    //  cap >> frame;
4. **加工与输出**：`cv::rectangle` 绘制模拟检测框，`cv::imshow` 实时显示或定时存图，用于验证图像正确性。

## 3. 关键代码逻辑理解 (重要记录)
1. 核心代码逻辑：    读取 (cap >> frame)：这是流操作，本质是把摄像头的缓冲区数据拷贝到内存。并非简单的函数调用，而是跨越 USB 总线、驱动层、应用层的多级数据同步。
2. 显式类型转换(static_cast<int>)：OpenCV 所有的 get 属性返回的都是 double。我们要用 static_cast 强制转为整数（如分辨率），这是为了防止类型不匹配的潜在风险。
3. 时间刻度 (duration<double>)：这里使用 <double> 是为了把高精度的纳秒时间差转换为带小数点的“秒”，确保 FPS 计算不为 0。

## 4.  硬件硬件排障
### 实时监控：sudo dmesg -w | grep -i usb。
1. 致命报错分析：timeout: still 11 active urbs on EP #86。
    URB (USB Request Block)：驱动层的“数据搬运任务”。
    报错含义：11 个数据包任务已下达，但在物理/虚拟传输层被挂起，无法返回。
    结论：程序逻辑无误，物理链路断裂。
2. 根治方案：
    协议升级：VMware 必须切换为 USB 3.1 (xHCI)，规避 USB 2.0 (EHCI) 的调度缺陷。
    物理换口：若协议切换无效，必须更换主机物理接口（优先选择原生蓝色 USB 3.x 接口）。

### JPEG 数据损坏 (Corrupt JPEG)
- **现象**：终端报错 `extraneous bytes before marker 0xd3`。
- **理解**：`0xd3` 是 JPEG 的 RST3 地标码。报错代表数据流中存在冗余字节，但 OpenCV 仍能根据地标恢复图像。

## 5.关键踩坑与解决方案汇总
1. 链路死锁：程序卡死且 dmesg 报 timeout
    根因：USB 2.0 (EHCI) 驱动无法承载视频流带宽，导致传输单元 (URB) 在端点 (EP #86) 挂起。
    对策：将虚拟机 USB 控制器升级为 USB 3.1 (xHCI)，并优先使用主机物理蓝色 USB 3.x 接口。
2. 画面干扰：终端刷屏 extraneous bytes before marker 0xd3
    根因：虚拟层转发抖动产生数据噪声。0xd3 是 JPEG 的 RST3 重同步标记，报错仅代表标记间有冗余字节。
    对策：忽略警告。OpenCV 可利用地标自动对齐图像，不影响算法逻辑。
3. 计算逻辑：FPS 始终为 0
    根因：时间差计算未处理精度，导致整数除法截断。
    对策：强制使用 std::chrono::duration<double> 转换为浮点秒后再进行运算。
4. 状态盲区：看不到分辨率输出
    根因：cap.get() 返回的是 double 且未执行标准输出。
    对策：配合 static_cast<int> 显式转换类型，并使用 std::cout 打印自检报告。



## 📅 第二周：CMake 与 OpenCV 环境集成
**日期**：2026-01-14

### 1. 任务进度
- [x] **规范化目录**：建立了 `src` (代码)、`include` (头文件)、`build` (编译产物) 标准结构。
- [x] **引入 OpenCV**：通过 `apt` 安装并成功在 CMake 中完成链接。
- [x] **跑通流水线**：使用 `cmake .. && make` 自动化生成可执行程序。

### 2. 核心知识点
- **CMake 的“隐身工作”**：
    - **自动识别依赖**：自动链接标准 C++ 库（libstdc++）。
    - **管理动态链接**：保持程序体积精简，运行时动态调用系统库。
- **路径原点逻辑**：`CMakeLists.txt` 中的路径永远以**文件本身位置**为基准，而非 `build` 文件夹位置。

### 3. 踩坑记录 (Troubleshooting)
- **路径偏差**：多加了 `../` 导致编译器越级寻找失败。
    - *心得*：在 CMake 中，`include` 就在 `CMakeLists.txt` 隔壁，直接写名字就行。
- **缓存残留**：修改脚本后编译不生效。
    - *对策*：**暴力清空法** —— `rm -rf *`。

### 4. 深度思考：大厨的“餐桌理论”
- **脚本先行**：在写代码前先改 CMake，就像是先给大厨备餐、发通行证。
- **环境赋能**：有了 CMake 的路径指引，VSCode 才能提供精准的代码补全。

### 5. 操作记录 (Quick Start)
```bash
# 修正后的标准流程
mkdir build && cd build
rm -rf * # 修改 CMakeLists 后必做
cmake ..
make
./opencv_test

### 【第 1 周】内存脱敏与图片底层逻辑
**日期**：2025-12-29
**今日进度**：
1. **工作流程**：完成了GitHub的使用流程。打通了 Windows(编辑) -> 共享文件夹 -> Ubuntu(编译) 的流水线。
2. **底层突破**：理解了图片在内存里其实就是一串“排好队的盒子”（一维数组）。
3. **关键公式**：掌握了 `index = y * width + x`。这是人类坐标系到计算机地址的“翻译官”。
4. **代码产出**：
   - `hello_rk.cpp`: 验证了编译器。
   - `pixel_memory.cpp`: 徒手操作内存像素。
   - `pixel_draw.cpp`: 操作像素并绘图。
   - `my_first_pixel.png`: 第一次用代码生成物理图片。

**踩坑记录**：
- **换行符陷阱**：最初在终端打印字符画时，由于把 `endl` 放错了循环位置，导致画面塌陷成一条直线。
- **公式对称性**：在做破坏性实验时，发现正方形的 x/y 对调看不出变化。理解了：只有画非对称图形（长方形）才能验证坐标转换的正确性。

**今日心得**：
> “计算机里没有二维数组，那只是人类的幻觉。” 
> 以前觉得图片很神秘，现在知道它就是一堆 `unsigned char`。这种能直接修改像素并看到图片变化的感觉，比看书强一百倍。

---

## 🛠️ 常用指令集 (备忘录)
- **编译**：`g++ filename.cpp -o output_name`
- **Git 存档**：`git add .` -> `git commit -m "..."` -> `git push`
